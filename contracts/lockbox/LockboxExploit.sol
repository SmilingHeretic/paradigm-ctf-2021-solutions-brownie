pragma solidity 0.4.24;

import "./Lockbox.sol";

interface EntrypointLongInput {
    function solve(bytes4) external;
}

contract LockboxExploit {
    event LogCalldata(string where, bytes calldata);
    Entrypoint entrypoint;

    constructor(Entrypoint _entrypoint) public {
        entrypoint = _entrypoint;
    }

    function testSignature(bytes32 r, bytes32 s) external pure returns (bool) {
        return
            ecrecover(keccak256("stage1"), uint8(28), r, s) ==
            0x7E5F4552091A69125d5DfCb7b8C2659029395Bdf;
    }

    function exploit(bytes32 r, bytes32 s) external {
        bytes4 selector = entrypoint.solve.selector;

        // bytes32 r = bytes32(
        //    0x18114ad07097b5f37d788165e45ca1b8462da0b578e5d37be4be363235d2fff6
        //);
        //bytes32 s = bytes32(
        //    0x1cba16f8eef716d06300c86e8aa1f74a057dc0543f157f9b21bacaa9d1efa29e
        //);

        bytes memory data;
        data = abi.encodePacked(
            selector,
            // to pass "do you feel lucky?"
            bytes4(blockhash(block.number - 1)),
            bytes27(0x00),
            // v
            uint8(28),
            r,
            s,
            // has to be even to pass "this is a bit odd"
            // and s < uint256(s) + 2 < choose_hash to pass "out of order"
            uint256(s) + 2,
            keccak256(abi.encodePacked("choose")),
            // idx % 4 == 0, so lock[0] has to equal keys[0] == r to pass "key did not fit lock"
            r,
            // so msg.data.length is small enough to pass stage 5 and choice % 6 == 4
            uint16(4)
        );
        emit LogCalldata("exploit", data);
        address(entrypoint).call(data);
    }
}
